% ********** Rozdział 2 **********
\chapter{Wstęp teoretyczny}
\label{sec:chapter2}

\section{Przegląd rynku}

Istniejący rynek oferuje szereg narzędzi wspomagających pracę zespołów w metodykach zwinnych, w tym Scrum. Poniżej zaprezentowano kilka popularnych rozwiązań, które stanowią punkt odniesienia dla realizowanej aplikacji.

\subsection{Atlassian Jira} 
\textbf{Jira} to jedno z najpopularniejszych narzędzi do zarządzania projektami informatycznymi w metodykach Agile i Scrum, rozwijane przez firmę Atlassian. Umożliwia zarządzanie backlogiem, planowanie sprintów, wizualizację postępu prac za pomocą tablic Kanban/Scrum, raportowanie oraz rozbudowaną konfigurację uprawnień i ról. Rozwiązanie dostępne jest w modelu SaaS z płatnością za każdego użytkownika. Jira cechuje się ogromną konfigurowalnością i bogatym ekosystemem dodatków, ale przez to może być trudna w szybkim wdrożeniu w mniejszych zespołach \cite{jira2025}. W porównaniu do Jiry, aplikacja w pracy wyróżnia się znacznie prostszym i bardziej ergonomicznym interfejsem - ograniczonym do najważniejszych elementów metodyki Scrum, co pozwala na szybsze wdrożenie i mniejsze obciążenie poznawcze dla zespołu.

\subsection{Monday.com}
\textbf{Monday.com} to narzędzie wizualne do zarządzania projektami, które umożliwia tworzenie tablic zadań, śledzenie postępu, definiowanie zależności i generowanie raportów. Choć wspiera metodologie Agile, jego głównym atutem jest elastyczny i intuicyjny interfejs użytkownika. Monday integruje się z wieloma narzędziami zewnętrznymi, ale nie oferuje pełnego wsparcia typowych artefaktów Scrum \cite{monday2025}.

\subsection{Asana}
\textbf{Asana} jest platformą do zarządzania zadaniami zespołowymi, wyposażoną w funkcje backlogu, harmonogramów, tablic zadań i raportów. Jest narzędziem ogólnego przeznaczenia, nie skupiającym się wyłącznie na Scrumie. Do tego, dostępna jest w modelu subskrypcyjnym \cite{asana2025}.

\section{Programowanie zwinne (Agile)}

Projekt realizowany w niniejszej pracy opiera się na modelu programowania zwinnego Scrum.
Programowanie zwinne (najczęściej określane z języka ang. Agile Programming) jest zbiorem praktyk i zasad ukierunkowanych na iteracyjne dostarczanie oprogramowania w stałym kontakcie z klientem. \cite{robert2003agile}  Fundamenty tego podejścia pojawiły się w latach 90. przy rozwoju metodyki \textit{Extreme Programming}, jednak prawdziwy przełom pojawił się w roku 2001 wraz z publikacją Manifestu Agile \cite{agilemanifesto2001}, który określa konkretne wartości i przekonania tej metodyki: ludzie i interakcje są ważniejsze niż procesy i narzędzia; tworzenie sprawnego oprogramowanie jest ważniejsze niż kompleksowa dokumentacja; współpraca z klientem jest ważniejsza nad negocjacji kontraktowych, oraz, reakcja na zmiany jest ważniejsza niż realizacja planów.

Co istotne, sam termin \textit{Agile} sam w sobie nie opisuje jednej, konkretnej metody wytwarzania programowania, lecz zestaw zasad i wartości, które znajdują zastosowanie w podejściach takich jak Extreme Programming, Scrum, czy Lean Software \cite{meyer2014agile}. Różnorodne podejścia wykorzystują różne podzbiory praktyk - część stosuje jedynie wybrane elementy Agile, bez wdrażania wszystkich zasad metodyki.

Bertrand Meyer zauważa, że Agile zyskał dużą rozpoznawalność nie tylko jako twardo określony zbiór technik wytwarzania oprogramowania, ale także jako pewnego rodzaju ruch i ideologia towarzysząca sposobowi myślenia o projektach informatycznych. Pojęcie Agile stało się modnym hasłem wykorzystywanym przez firmy podczas prowadzonych kampanii reklamowych o pracę, próbując w ten sposób przyciągnąć najlepszych programistów. \cite{meyer2014agile} 

W podejściu zwinnego programowania najważniejszym konceptem jest otwartość na zmiany podczas realizacji projektów oraz akceptacja, że nie jest w praktyce możliwe kompletne i dokładne zdefiniowanie wymagań projektowych przed rozpoczęciem prac. Założeniem Agile jest, że potrzeby użytkowników, a także otoczenie biznesowe mogą zmieniać się dynamicznie - dlatego proces wytwórczy oprogramowania musi być adaptowany.

Agile kładzie również silny nacisk na współpracę i komunikację. W tradycyjnych modelach tworzenia oprogramowania proces jest sekwencyjny i oparty o liczne przekazania pracy pomiędzy różnymi działami - analizą, projektowaniem, implementacją i testami. Taki sposób organizacji pracy zespołu prowadzi do ryzyka zniekształcenia ciągle przekazywanych informacji. Metody zwinne rozwiązują lub w pewnym stopniu mitygują ten problem poprzez formułowanie mniejszych zespołów które współdziałają intensywnie i bezpośrednio. Dzięki temu decyzje techniczne, jak i biznesowe mogą być podejmowane szybko i implementowane w kontrolowany sposób.

Kolejnym fundamentem metod Agile jest dostarczanie w krótkich odstępach czasu działających, przetestowanych i kompletnych fragmentów systemu. Inkrementy, czyli niewielkie przyrosty funkcjonalności dodawane do produktu w każdej iteracji, pozwalają na bieżąco oceniać postępy i jakość wytwarzanego rozwiązania. Regularne dostawy funkcjonalności są nie tylko formą weryfikacji pracy zespołu, ale też narzędziem do gromadzenia informacji zwrotnej od klienta, który ma kluczowe znaczenie dla kolejnych etapów projektu. W ten sposób wymagania mogą być stopniowo doprecyzowane, eliminując konieczność planowania z dużym wyprzedzeniem.

% manifest we wstepie

\clearpage

\section{Scrum}
\label{sec:scrum}

Scrum jest jedną z najpopularniejszych i najlepiej udokumentowanych \textit{implementacji metodyk} zwinnych Agile, stosowanych do zarządzania złożonymi projektami informatycznymi. Scrum rozwija ideę iteracyjno–przyrostowego wytwarzania oprogramowania, koncentrując się na krótkich iteracjach, niewielkich zespołach oraz stałej gotowości do reagowania na zmiany wynikające z otoczenia biznesowego. W przeciwieństwie do tradycyjnych, sekwencyjnych modeli wytwarzania oprogramowania zakłada on, że proces rozwoju systemu jest w dużej mierze nieprzewidywalny i powinien być traktowany jako proces oparty na ciągłej obserwacji i weryfikacji, kontrolowany z zewnątrz za pomocą prostych, lecz konsekwentnie stosowanych mechanizmów nadzoru. \cite{schwaber2004scrum}

\subsection{Charakterystyka i założenia metodyki Scrum}

Systemy informatyczne powstają w środowisku o wysokiej złożoności i zmienności, a wiele tradycyjnych modeli zakłada zbyt duży poziom przewidywalności procesu \cite{schwaber2004scrum}. Scrum przyjmuje odwrotne założenie zgodne z metodyką Agile: analiza, projekt i implementacja są na tyle złożone, że nie da się ich szczegółowo opisać z góry, dlatego proces jest traktowany jako \textit{czarna skrzynka}, a nad nim budowane są mechanizmy kontrolne takie jak m.in. stała długość iteracji, regularne przeglądy postępu oraz jawne zarządzanie ryzykiem.

Kluczowym elementem Scruma jest iteracyjno–przyrostowy rozwój systemu. Praca dzielona jest na Sprinty trwające zazwyczaj od jednego do czterech tygodni. W ramach każdej iteracji zespół dostarcza działający przyrost produktu, który można uruchomić, przetestować i skonsultować z interesariuszami. Dzięki temu decyzje dotyczące kierunku rozwoju systemu mogą być podejmowane na podstawie faktycznie działającego oprogramowania, a nie wyłącznie dokumentacji czy założeń projektowych, które często okazują się być niedokładne.

\subsection{Fazy procesu i Sprinty}

Scrum organizuje pracę zespołu wokół cyklu obejmującego przygotowanie zakresu, iteracyjną realizację Sprintów oraz regularne działania usprawniające. Zanim rozpocznie się właściwy cykl iteracyjny, zespół określa zakres nadchodzącego wydania, szacuje koszty, przygotowuje harmonogram oraz wstępne założenia architektoniczne \cite{braz2015development}. Efektem tych przygotowań jest wstępny backlog produktu oraz ogólna wizja kierunku rozwoju systemu.

Centralnym elementem procesu są Sprinty, trwające zazwyczaj od jednego do czterech tygodni. Każdy Sprint rozpoczyna się planowaniem (\textit{Sprint Planning}), podczas którego ustalany jest cel iteracji i wybierane są elementy backlogu do realizacji. W trakcie Sprintu odbywają się codzienne spotkania koordynacyjne (\textit{Daily Scrum}), wspierające monitorowanie postępu prac i identyfikację przeszkód. Iteracja kończy się przeglądem wyników (\textit{Sprint Review}), podczas którego prezentowany jest działający przyrost produktu, pozwalający interesariuszom na bieżącą ocenę i zgłaszanie informacji zwrotnej \cite{mueller2013data}. Kluczową wartością takiego podejścia jest systematyczne dostarczanie kolejnych, zawsze potencjalnie wdrażalnych przyrostów oprogramowania.

Po każdym Sprincie zespół przeprowadza retrospektywę, której celem jest analiza przebiegu prac, identyfikacja problemów oraz zaplanowanie działań usprawniających przyszłe iteracje.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/scrum_fazy}
\caption{Graf reprezentujący przebieg projektu w modelu Scrum, Źródło: \cite{braz2015development}}
\label{fig:1}
\end{figure}

\subsection{Zespół, role i backlog}

Scrum zakłada pracę niewielkich, interdyscyplinarnych zespołów liczących zwykle od trzech do ośmiu osób. Mała liczebność ułatwia komunikację i umożliwia szybkie podejmowanie decyzji. Zespół deweloperski jest samoorganizujący się - sam wybiera sposób realizacji zadań oraz dzieli odpowiedzialności. Obok zespołu deweloperskiego, Scrum definiuje także dodatkowe role: \textit{Product Owner} oraz \textit{Scrum Master}. Product Owner odpowiada za backlog produktu i priorytety funkcjonalności, reprezentując interesy biznesowe. Scrum Master dba o poprawne zastosowanie metod Scruma i wspiera komunikację wewnątrz zespołu.

Backlog jest kluczowym narzędziem w Scrum. Pełni on funkcję centralnego narzędzia zarządzania zakresem prac. Zawiera uporządkowaną listę wymagań, poprawek, usprawnień systemu i innych zadań, które mogą zostać w przyszłości zrealizowane. Backlog jest aktualizowany na bieżąco w odpowiedzi na zmiany w otoczeniu biznesowym, przy otrzymaniu wyników testów czy gdy pojawiają się nowe potrzeby użytkowników lub klienta. Podczas planowania Sprintu z backlogu wybierany jest podzbiór elementów, które zespół zobowiązuje się zrealizować w danej iteracji.

\subsection{Kategoryzacja zadań Backlogu}

Elementy backlogu produktu mogą być opisywane na różnym poziomie szczegółowości, dlatego dzieli się je na trzy kategorie: epiki, historyjki użytkowników oraz zadania. Epik (ang. \textit{epic}) to duże, złożone wymaganie lub funkcjonalność - zbyt obszerne, by mogło być zrealizowane w zakresie pojedynczego sprintu \cite{braz2015development}. Stanowi punkt wyjścia do dalszego doprecyzowania szczegółowych wymagań i zwykle jest w naturalny sposób dzielony na mniejsze części w trakcie pracy.

Tymi mniejszymi elementami są \textit{historyjki użytkownika} (ang. \textit{story}). Każda z nich opisuje konkretną potrzebę lub oczekiwaną funkcję z perspektywy użytkownika. Historyjki najczęściej formułuje się według schematu "Jako [użytkownik] chcę [osiągnąć cel] aby [uzasadnienie]." Powinny być one niewielkie i możliwe do wykonania w ramach pojedynczego sprintu.

Najbardziej szczegółowymi elementami są \textit{zadania techniczne} (ang. \textit{task}), które rozbijają realizację historyjek na konkretne czynności do wykonania przez zespół deweloperski \cite{ahalabsmisc}. Zadanie zazwyczaj dotyczy pojedynczego aspektu prac (np. implementacja określonej funkcji, przygotowanie bazy danych czy napisanie testów jednostkowych). Zadania same w sobie nie muszą przynosić użytkownikowi bezpośrednio wartości, ale są niezbędne, by ukończyć historyjkę.

Taki podział backlogu na epiki, historyjki i zadania ułatwia zarządzanie zakresem i postępem prac. Do tego zachowana jest hierarchia celów: ogólne cele biznesowe (epiki), konkretne wymagania użytkowników (historyjki) i plan pracy dla zespołu (zadania).

\clearpage

\section{Język PHP}

\subsection{Krótka Historia}

Język \textit{PHP} powstał w 1994 roku z inicjatywy Rasmusa Lerdorfa jako zestaw skryptów wspomagających stronę osobistą. Szybko przekształcił się w pełnoprawny język programowania - od wersji 3 (1998) przyjął nazwę \textit{PHP: Hypertext Preprocessor}, zyskując nowe możliwości i model obiektowy \cite{phpnet}. W kolejnych latach rozwój przyspieszył dzięki wprowadzeniu silnika \textit{Zend}, który znacząco poprawił wydajność i elastyczność języka \cite{phpnet}.

\subsection{Definicja języka}

PHP jest otwartoźródłowym, skryptowym językiem programowania uruchamianym po stronie serwera, zaprojektowanym z myślą o tworzeniu stron internetowych i aplikacji webowych. Kod PHP można osadzać bezpośrednio w kodzie HTML, dzięki czemu służy on do generowania dynamicznej zawartości stron WWW \cite{mdn2025php}. Dzięki składni zbliżonej do języków C i Perl, PHP szybko zdobył popularność wśród twórców stron WWW. Skrypty PHP są wykonywane na serwerze WWW - oznacza to, że PHP zajmuje się obsługą logiki aplikacji webowych w warstwie serwerowej (tzw. \textit{backend}), podczas gdy przeglądarka klienta otrzymuje już gotową stronę wynikową.

\subsection{Charakterystyka programowania w PHP}

Kod pisany w PHP przypomina kod C, ponieważ bierze z niego inspiracje. Składa się on z instrukcji oddzielanych średnikami, bloki kodu są oznaczane nawiasami klamrowymi, a zmienne poprzedzane są znakiem \verb+$+. PHP jest językiem dynamicznie typowanym (luźno typowanym), co oznacza że typy danych zmiennych sprawdzane są dopiero w czasie wykonania programu, a nie są deklarowane na stałe w kodzie, jak to robi się w większości kompilowanych języków, typu C. Początkowo pisany w modelu strukturalnym, od czasu wydania wersji 5 języka PHP oferowany jest model obiektowy, który stał się dominującym sposobem pisania kodu w większości nowoczesnych bibliotek i frameworków stosujących PHP (m.in. \textit{Laravel}).
Programowanie w PHP charakteryzuje się krótkim cyklem "pisz-uruchom": dzięki interpretowanej naturze kodu, zmiany w skryptach można testować od razu – wystarczy zapisać plik i odświeżyć stronę w przeglądarce, bez potrzeby osobnej kompilacji programu \cite{ibmphp}.

\subsection{Zastosowania PHP}

Ze względu na swoją konstrukcję PHP jest wykorzystywany głównie do programowania strony serwerowej aplikacji internetowych, generowania dynamicznych treści stron i komunikacji z bazami danych. PHP współpracuje ściśle z serwerami HTTP (np. Apache lub Nginx) - serwer przekazuje żądania dotyczące plików PHP do interpretera, który wykonuje kod i zwraca gotową stronę HTML do wysłania klientowi \cite{ibmphp}. PHP jest fundamentem wielu popularnych systemów zarządzania treścią takich jak WordPress, który - według statystyk W3Techs - zasila około 43\verb+%+ wszystkich witryn internetowych \cite{w3techs}. PHP sprawdza się zarówno w małych stronach i prototypach, jak i w dużych serwisach o globalnej skali. Do najbardziej znanych witryn korzystających z PHP należą Wikipedia oraz Facebook. Serwisy te w swojej zasadniczej części backendu były lub są zaimplementowane w PHP.

\subsection{Popularność i statystyki}

Pomimo pojawienia się wielu nowych technologii webowych, PHP wciąż utrzymuje silną pozycję w ekosystemie tworzenia stron internetowych. Według badań W3Techs, na koniec 2025 roku PHP jest używany po stronie serwera przez około 72,9\verb+%+ wszystkich witryn, dla których znany jest zastosowany język programowania \cite{w3techs}. W środowisku programistów PHP również pozostaje jednym z najczęściej wykorzystywanych języków - przykładowo, w globalnej ankiecie Stack Overflow z roku 2025 około 18,9\verb+%+ ankietowanych developerów wskazało, że używa PHP na co dzień \cite{stackoverflow2025survey}.

\clearpage

\section{Model MVC}

Model-View-Controller (MVC) jest jednym z najpopularniejszych wzorców architektonicznych stosowanych przy tworzeniu aplikacji. Jego głównym założeniem jest separacja logiki biznesowej od warstwy prezentacji, co ułatwia podział pracy. Wzorzec MVC dzieli aplikację na trzy komponenty: Model, odpowiadający za przechowanie i obsługę danych, Widok, odpowiedzialny za interfejs użytkownika i prezentację danych; oraz Kontrolery, przyjmujące i obsługujące żądania użytkowników, modyfikując stan Modelu i decydujący o aktualizacji widoków \cite{mdn2025mvc}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/mvc.png}
    \caption{Model MVC, Źródło: \cite{mdn2025mvc}}
    \label{fig:placeholder}
\end{figure}

\section{Środowisko Laravel}

\subsection{Definicja}

Laravel to otwartoźródłowy framework aplikacji internetowych napisany przy użyciu języka PHP, zapoczątkowany przez Taylora Otwella. Zapewnia on nowoczesne środowisko do budowany aplikacji zgodnie z architekturą MVC i kładzie duży nacisk na czytelność kodu oraz wygodę programisty \cite{mdn2025laravel}.

Framework ten dostarcza m.in. mechanizm routingu, system szablonów \textit{Blade}, ORM \textit{Eloqent} do interakcji bazą danych oraz wsparcie dla migracji i narzędzia do testowania. Kod aplikacji zorganizowany jest w moduły odpowiadające poszczególnym warstwom systemu (np. \textit{Models}, \textit{Controllers} i \textit{views}), co pozwala oddzielić logikę biznesową od prezentacji i uprościć rozwój dużych projektów.

%% TODO 
Laravel najlepiej sprawdza się przy budowie stron internetowych, ale jest także odpowiedni do serwerów \textit{Rest API} i \textit{Websocket}.

\begin{lstlisting}[language=php,caption={Przykładowy kod ścieżki i kontrolera Laravel}, label={lst:laravel-sample}]
Route::get("/api/tasks", [TaskController::class, "index"]);

class TaskController extends Controller {
    public function index() {
        return response()->json(Task::all());
    }
}
\end{lstlisting}

Dodatkowo, Laravel oferuje rozbudowany ekosystem pakietów, obszerną dokumentację i dobre wsparcie społeczności \cite{laravel2025docs}, co sprawia, że framework ten pozostaje jednym z najczęściej wykorzystywanych frameworków PHP według ankiety Stack Overflow z 2025 roku \cite{stackoverflow2025survey}.

\subsection{Komponent Laravel - Eloquent ORM}
Eloquent ORM to wbudowany w Laravel mechanizm mapowania obiektowego-relacyjnego (\textit{ORM}), który odwzorowuje tabele bazy danych na klasy modeli. Za pomocą modeli Eloquent programista może wykonywać operacje CRUD (tworzenie, odczyt, aktualizacja i usuwanie) na danych poprzez wywoływanie metod PHP zamiast bezpośredniego konstruowania zapytań SQL. Takie podejście w stylu Active Record upraszcza programowanie aplikacji i czyni interakcję z bazą danych bardziej intuicyjne \cite{laravel2025docs}.

\subsection{Komponent Laravel - Blade}
Blade jest silnikiem szablonów zapewniający czystą i przejrzystą składnię do tworzenia widoków. Ułatwia umieszczanie dynamicznych danych w kodzie HTML oraz dodaje instrukcje warunkowe wykonywane po stronie serwera.

\section{Biblioteka React}

\subsection{Definicja}

React.js jest najpopularniejszą biblioteką \cite{stackoverflow2025surveyTech} do obsługi interfejsu użytkownika w reaktywny sposób. Biblioteka ta została stworzona przez firmę Meta (dawniej Facebook) i jest udostępniona jako projekt open-source. Zaprojektowana jest z myślą o budowaniu dynamicznych interfejsów użytkownika, szczególnie w aplikacjach jednostronnych SPA.

\subsection{Reaktywność interfejsu użytkownika}

React opiera się na deklaratywnym, reaktywnym podejściu do budowy interfejsu. Programując w React, definiuje się proste widoki dla każdego stanu aplikacji, a biblioteka automatycznie aktualizuje i renderuje komponenty, które uległy zmianie, gdy dane się zmieniły. Ponadto, mechanizm wirtualnej DOM sprawia, że zmiany w interfejsie są wydajniejsze - aktualizowane są jedynie elementy które faktycznie się zmieniły.

\subsection{Język JSX}
React głównie programuje się przy pomocy składni JSX (skrót JavaScript XML), będącą rozszerzeniem składni języka JavaScript umożliwiającym pisanie kodu przypominającego HTML bezpośrednio w plikach JS \cite{w3schools2025jsx}. Notacja JSX pozwala opisywać strukturę komponentów w bardziej intuicyjny sposób - zbliżony do szablonów HTML - zachowując jednocześnie pełną moc języka JavaScript w kodzie interfejsu. Używanie JSX w React nie jest obowiązkowe, lecz stało się powszechnym standardem ze względu na znaczne zwiększenie czytelności i wygody definicji komponentów.



\begin{lstlisting}[language=C++,caption={Przykładowy komponent zdefiniowany za pomocą JSX}, label={lst:jsx-sample}]
function Welcome({ name }) {
    return <h1>Hello, {name}.</h1>
}

<Welcome name="Przyklad" />
\end{lstlisting}

% opisać co było w komentarzach

\clearpage

\subsection{Charakterystyka React i zastosowania}

React ma charakter komponentowy - aplikacje składają się z małych, kapsułkowanych komponentów, z których każdy zarządza własnym stanem i może być wielokrotnie używany w różnych częściach interfejsu \cite{react2025main}. Takie podejście ułatwia utrzymanie spójności i reużywalności kodu oraz rozwój dużych aplikacji, redukując duplikację kodu i liczbę błędów.

React jest wykorzystywany przede wszystkim do tworzenia aplikacji webowych o dynamicznym interfejsie użytkownika. Najlepiej sprawdza się przy implementacji aplikacji jednostronnej (SPA), gdzie zawartość strony aktualizuje się dynamicznie przy pomocy skryptów JavaScript, a nie pełnymi przeładowaniami strony. Ponadto, koncepty Reacta zostały także zaadaptowane do tworzenia aplikacji mobilnych przy pomocy biblioteki React Native, która umożliwia budowanie natywnych aplikacji na platformy Android i iOS przy użyciu komponentów React \cite{curotec2025}.

\section{Pozostałe technologie}

\subsection{PostgreSQL}

PostgreSQL to otwartoźródłowy relacyjny system baz danych ceniony za niezawodność, bogaty zestaw funkcji oraz wysoką wydajność \cite{postgres2025}. Postgres jest w pełni obsługiwany przez framework Laravel (jako jeden z domyślnych silników baz danych Eloquent ORM), dzięki czemu może być używany jako wydajny backend bazy danych w aplikacjach tworzonych w Laravelu~\cite{laravel2025docs}.

\subsection{Inertia}

Inertia.js to biblioteka umożliwiająca integrację Laravel z nowoczesnymi frontendowymi frameworkami (jak React) w celu tworzenia aplikacji jednostronicowych (SPA), bez konieczności budowania odrębnego API REST \cite{inertia2025docs}. Dzięki Inertia logika routingu, kontrolery i autoryzacja pozostają po stronie serwera, natomiast interfejs użytkownika renderowany jest po stronie klienta w postaci komponentów React.

\subsection{Komponenty shadcn/ui}

Komponent \textit{shadcn/ui} to biblioteka komponentów interfejsu użytkownika dla Reacta, zbudowana w oparciu o prymitywy Radix UI oraz Tailwind CSS \cite{infinum2025Shadcn} przez członka firmy Vercel, \textit{shadcn}. Shadcn/ui dostarcza gotowe szablony komponentów (np. przyciski, okna dialogowe, tabele), które można - za pomocą CLI lub manualnie - kopiować bezpośrednio do własnego projektu, zyskując pełną kontrolę nad ich kodem i wyglądem. Zastosowanie biblioteki komponentów ułatwia integrację z aplikacjami oraz zapewnia jednolity język projektowy wyglądu aplikacji.

\subsection{Platforma GitHub (OAuth2 i API)}

GitHub umożliwia aplikacjom zewnętrznym uwierzytelnianie użytkowników za pomocą protokołu OAuth 2.0, co potocznie nazywane jest "logowaniem przez GitHub" \cite{github2025rest}. Użytkownik loguje się na swoje konto GitHub i udziela aplikacji zgody na dostęp, po czym aplikacja otrzymuje token OAuth – pozwala on bezpiecznie pobrać podstawowe informacje profilu lub wykonywać akcje w imieniu użytkownika (np. zarządzanie repozytoriami) poprzez API GitHuba \cite{tony2023}.

Ponadto GitHub udostępnia bogate API Rest, które pozwala m.in. pobierać dane o repozytoriach, użytkownikach czy zgłoszeniach oraz automatyzować operacje, integrując w ten sposób zewnętrzne aplikacje z ekosystemem GitHuba.

\clearpage

% ********** Koniec rozdziału **********
