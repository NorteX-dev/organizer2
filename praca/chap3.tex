% ********** Rozdział 3 **********
\chapter{Implementacja aplikacji}
\label{sec:chapter3}

\section{Struktura projektu}

Ponieważ projekt bazuje na Laravel, praca została rozpoczęta podobnie do każdego innego projektu w Laravel, tj. stworzeniem i konfiguracją podstawowej struktury plikowej projektu Laravel przy pomocy narzędzia CLI Laravel. Uruchomienie komendy powoduje stworzenie folderu projektu o nazwie \textit{organizer}.

Poniżej przedstawiony diagram reprezentuje podstawową strukturę plikową projektu w momencie zakończenia prac. Nie jest on jednak oddalony od domyślnej struktury plikowej Laravel, bezpośrednio po wygenerowaniu przez narzędzie generatora CLI. Główną różnicą jest domyślny brak folderów \textit{Policies} i \textit{Events}, które są tworzone dopiero przy utworzeniu pierwszej polityki autoryzacji lub wydarzenia. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{img/struktura.png}
    \caption{Diagram reprezentujący strukturę plikową projektu Laravel}
    \label{fig:placeholder}
\end{figure}

Laravel jest frameworkiem monolitycznym, dlatego większość logiki biznesowej i wyświetleniowej znajduje się w jednolitym folderze aplikacji, na diagramie oznaczonym jako \textit{Aplikacja Laravel} w kolorze pomarańczowym.

Aplikacja Laravel rozbija się na dziewięć kluczowych folderów, które zawierają:

\begin{enumerate}
    \item \textbf{app/} - duża część kodu źródłowego aplikacji pisanej w Laravel. Rozbija się na charakterystyczne dla Laravel podfoldery:
    \begin{itemize}
        \item \textit{Console} - miejsce na pliki źródłowe komend terminalowych narzędzia \textit{artisan},
        \item \textit{Events} - wydarzenia aplikacji,
        \item \textit{Http} - warstwa internetowa HTTP aplikacji (zawierająca kontrolery modelu MVC, middleware i formaty żądań),
        \item \textit{Models} - modele bazy danych Eloquent ORM,
        \item \textit{Policies} - polityki autoryzacji,
        \item \textit{Providers} - klasy ładowane za każdym uruchomieniem żądania.
    \end{itemize}

    \item \textbf{bootstrap/} - plik wejściowy \textit{app.php} oraz pliki pamięci podręcznej cache.
    \item \textbf{config/} - pliki konfiguracyjne komponentów Laravel oraz bibliotek z opublikowanym plikiem konfiguracyjnym.
    \item \textbf{public/} - pliki dostępne publicznie na adresie URL aplikacji,
    \item \textbf{resources/} - zasoby warstwy wyświetlenia, takie jak szablony HTML, szablony CSS i skrypty JavaScript.
    \item \textbf{routes/} - podstawowo zawierający pliki \textit{web.php} i \textit{console.php}, definiują ścieżki aplikacji i określają jak mają być dysponowane żądania po kontrolerach.
    \item \textbf{storage/} - dedykowany do przechowywania plików zapisywanych podczas pracy aplikacji.
    \item \textbf{vendor/} i \textbf{node\_modules/} - pliki wewnętrzne narzędzi do obsługi bibliotek PHP i Node.js, odpowiednio: \textit{Composer} i \textit{NPM}.
\end{enumerate}

Dodatkowo określona jest warstwa bazy danych, w której znajdują się migracje bazy danych (\textit{migrations}), inicjalizacja danych (\textit{seeders}) i fabryki (\textit{factories}). Migracje są najważniejszym elementem z trzech, ponieważ określają strukturę bazy danych relacyjnej bazującej na SQL. Przy pomocy metod PHP, określić można akcje które powinny być podjęte aby osiągnąć ostateczny schemat bazy danych, np. stworzenie tabel, definicja kolumn, migracja danych i operacje odwrotne do tych.

\clearpage

\begin{lstlisting}[language=php,caption={Wycinek kodu migracji odpowiedzialnej za stworzenie tabelę "users"}, label={lst:migration-sample}]

<?php
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create("users", function (Blueprint $table) {
            $table->id();
            $table->string("name");
            $table->string("email")->unique();
            $table->timestamp("email_verified_at")->nullable();
            $table->rememberToken();
            $table->timestamps();
        });
        
        // ...
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists("users");
    }
};
\end{lstlisting}

Przy pomocy komendy CLI \texttt{php artisan migrate} zmiany na bazie danych określone przez powyższy kod są aplikowane na bazę danych i gotowe do zastosowania w aplikacji.

W każdym projekcie Laravel znajduje się także zasadniczy plik konfiguracyjny środowiska oznaczony nazwą \texttt{.env}. W pliku tym definiuje się dane takie jak nazwa aplikacji, adres URL aplikacji, klucz szyfrowania, dane połączeniowe i autoryzacyjne do bazy danych, jak i inne elementy konfiguracyjne które są zmienne w zależności od środowiska.

\clearpage

\section{Obsługa logowania GitHub OAuth 2.0}

Obsługa logowania GitHub OAuth 2.0 została opracowana przy pomocy biblioteki Laravel Socialite, która znacznie ułatwia integrację logowania przez platformy trzecie (jak GitHub) i jest zalecaną metodą implementacji protokołu OAuth 2.0 w aplikacjach Laravel \cite{laravel2025docs}.

\subsection{Konfiguracja pakietu Laravel Socialite}

Do implementacji protokołu OAuth 2.0 wymagana jest para kluczy: klucz publiczny i klucz prywatny. Dodatkowo musi być określona zwrotna ścieżka URL po autoryzacji przez platformę trzecią. Konfiguracja kluczy GitHub w Laravel Socialite odbywa się poprzez definicję zmiennych konfiguracyjnych w pliku \texttt{.env}:

\begin{lstlisting}[caption={Definicja zmiennych środowiskowych Socialite}, label={lst:socialite-env}]
GITHUB_CLIENT_ID=Ov23li7GWo*********
GITHUB_CLIENT_SECRET=c7e33a************************
GITHUB_REDIRECT_URI=http://localhost:8000/auth/github/callback
\end{lstlisting}

\begin{lstlisting}[language=PHP,caption={Definicja ścieżek logowania przez OAuth}, label={lst:socialite-routes}]
Route::get("/auth/github", [GitHubController::class, "redirect"])
    ->name("auth.github");
Route::get("/auth/github/callback", [GitHubController::class, "callback"])
    ->name("auth.github.callback");
\end{lstlisting}

Ostatecznym, lecz nie mniej ważnym komponentem implementacji pakietu Laravel Socialite jest stworzenie dwóch ścieżek: przekierowującej na stronę dostawcy i odbierających powrót na stronę. Wraz z tymi ścieżkami, został określony kontroler obsługujący żądania.

\clearpage

\subsection{Przycisk i strona logowania}

\begin{lstlisting}[language=JavaScript,caption={Komponent przycisku logowania},label={lst:loginreact}]
<Button asChild className="w-full" size="lg" data-test="login-button">
    <a href="/auth/github">
        <Github className="mr-2 h-5 w-5" />
        Kontynuuj z GitHub
    </a>
</Button>
\end{lstlisting}

Pełny system logowania opiera się na przebiegu wydarzeń który składa się z:
\begin{itemize}
    \item Przycisk, który wysyła użytkownika na adres logowania \texttt{/auth/github};
    \item Przekierowanie na platformę GitHub, aby uzyskać autoryzację użytkownika;
    \item Platforma GitHub zwraca użytkownika na stronę aplikacji przez przekierowanie na URL powrotny;
    \item Wewnętrznie, przy pomocy biblioteki Laravel Socialite, wymieniany jest kod autoryzacji na token dostępowy GitHub;
    \item Użytkownik może być zalogowany i zapisany do sesji Laravel.
\end{itemize}

\clearpage

\section{Zespoły, role i projekty}

\subsection{Założenia architektoniczne systemu zespołów}

Architektura projektu jest zaprojektowana w sposób hierarchiczny, w którym najwyższym szczeblem hierarchii są zespoły. Zespoły można w dowolnym momencie utworzyć, usunąć i istnieje możliwość zapraszania dodatkowych członków. Reprezentowane są w kodzie źródłowym jako model \texttt{Team} i jest przypisana im tabela w bazie danych \texttt{"teams"}.

W poszczególnych zespołach można tworzyć i usuwać według uznania i potrzeb zespołu projekty, które stanowią niższy szczebel hierarchii. Projekty posiadają nazwę, domyślny czas sprintów i inne dane projektowe. Z założenia architektonicznego, każdy członek zespołu ma dostęp do każdego projektu w owym zespole - nie ma zaimplementowanej możliwości ukrywania określonych projektów przed specyficznymi członkami projektu. W takim przypadku, zaleca się utworzyć nowy zespół.

Aby rozpocząć używanie aplikacji, wymagane jest, aby posiadać co najmniej jeden zespół, z co najmniej jednym członkiem o odpowiednich uprawnieniach, i co najmniej jeden projekt w zespole.

\subsection{Struktura bazy danych}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{img/teamsprojectsdiag.png}
    \caption{Diagram relacyjny tabel związanych z obsługą zespołów i projektów}
    \label{fig:placeholder}
\end{figure}

Struktura relacji zespołów do projektów opiera się na prostej relacji, w której zespoły mogą posiadać wiele lub zero projektów.  

\subsection{Implementacja logiki zespołów}

Segment obsługi zespołów aplikacji - podobnie do innych modeli zastosowanych w projekcie - jest implementacją struktury CRUD (\textit{create, read, update, delete}), w której implementowane są akcje tworzenia, odczytu danych (odczyt pojedynczych rekordów i listowania wielu), aktualizacji danych i ich usuwania.


CRUD w zespołach jest realizowany przez ścieżki URL rozpoczynające się na \texttt{/teams}.

\begin{lstlisting}[language=PHP,caption={Kod definiujący ścieżki CRUD /teams},label={lst:teams-route}]
Route::resource("teams", App\Http\Controllers\TeamController::class);
\end{lstlisting}

Metoda \texttt{Route::resource()} jest pomocniczym, abstrakcyjnym sposobem na jednoczesne stworzenie siedmiu ścieżek URL typowych akcji CRUD. Są one przypisane konkretnym nazwom metod kontrolera:
\begin{itemize}
    \item Metoda \texttt{index} wyświetlająca interfejs użytkownika listujący dane;
    \item Metoda \texttt{create} wyświetlająca interfejs użytkownika do tworzenia nowych rekordów;
    \item Metoda \texttt{store} do zapisu danych po wypełnieniu formularza;
    \item Metoda \texttt{show} wyświetlająca interfejs użytkownika do wyświetlenia poszczególnego rekordu;
    \item Metoda \texttt{edit} wyświetlająca interfejs użytkownika do edycji istniejących rekordów;
    \item Metoda \texttt{update} do zapisu zmian;
    \item Metoda \texttt{destroy} do usuwania rekordów.
\end{itemize}

W przypadku implementacji zespołów, zostały zaimplementowane także dodatkowe ścieżki poza podstawowymi, wynikającymi z modelu CRUD. Są to ścieżki zapraszania użytkowników do zespołu, usuwania członków, aktualizacji ról członków i zmiany aktualnie wybranego zespołu.

Aktualnie wybrany zespół jest zapisywany w sesji serwera dla danego żądania. W ten sposób, aplikacja zawsze wie, jaki jest aktualnie wybrany zespół - wpływa to na stan aplikacji, np. dostępne projekty.

\subsection{System ról Scrum}

Aplikacja jest blisko zintegrowana z modelem programowania zwinnego Scrum, dlatego role dostępne w aplikacji odzwierciedlają strukturę zespołową w tym modelu. Dostępne w aplikacji role zespołowe to deweloper, \textit{Scrum Master}, \textit{Project Owner} i dodatkowa rola administratorska, nosząca uprawnienia wszystkich powyżej wymienionych - wymagana na potrzeby testowania ręcznego aplikacji "na bieżąco".

W zależności od roli, użytkownicy posiadają różne poziomy uprawnień do modyfikacji danych w aplikacji. Przykładem są członkowie z rolą dewelopera, którzy nie mają dostępu do backlogu projektu. Zostało to zaimplementowane za pomocą polityk autoryzacji które oferuje Laravel (\textit{Laravel Policies}).

\begin{lstlisting}[language=PHP,caption={Fragment przykładowego kodu określającego poziom uprawnień członka na podstawie ustawionej roli},label={lst:perms-check}]
return $user->hasAnyRole($team, ["admin", "scrum_master"]);
\end{lstlisting}

\subsection{Obsługa zapraszania członków}
Zapraszanie członków jest realizowane przez podanie w formularz zapraszania adresu e-mail użytkownika docelowego, którego chcemy zaprosić. Jest to wykonywane przez prosty system, który sprawdza, czy użytkownik z podanym e-mailem istnieje. W przypadku gdy użytkownik został znaleziony, system upewnia się, że użytkownik nie jest już dodany do zespolu. Jeżeli każdy warunek zostanie spełniony, członek jest przypisywany do zespołu z rolą dewelopera (najniższa w hierarchii ról rola).

\begin{lstlisting}[language=PHP,caption={Realizacja zapraszania członków},label={lst:teams-addmember}]
public function addMember(Request $request, Team $team)
{
    $this->authorize("update", $team);
    $request->validate([
        "email" => ["required", "email", "exists:users,email"],
    ]);
    $user = User::where("email", $request->email)->first();
    if ($team->users()->where("user_id", $user->id)->exists()) {
        return back()->withErrors(["email" => "[...]"]);
    }
    $team->users()->attach($user->id, ["role" => "developer"]);
    return back()->with("success", "[...]");
}
\end{lstlisting}

\subsection{Obsługa projektów}

Projekty także korzystają z wcześniej wymienionej struktury CRUD i posiadają taką samą strukturę bazową kontrolera jak kontroler zespołów. Różnice się pojawiają dopiero w kodzie realizującym synchronizację projektów open-source przez GitHub API, opisanej poniżej. Zaimplementowano także interfejs użytkownika składający się z formularza edycji danych projektowych i zakładki synchronizacji.

\begin{lstlisting}[language=JavaScript,caption={Fragment formularza projektu},label={lst:teams-route}]
<form className="space-y-5" onSubmit={handleSave}>
    <Tabs value={activeTab} onValueChange={handleTabChange}>
        <TabsList>
            <TabsTrigger value="details">Szczegoly</TabsTrigger>
            <TabsTrigger value="integration">Integracja</TabsTrigger>
        </TabsList>
        <TabsContent value="details" className="space-y-5 pt-4">
            <div className="space-y-2">
                <Label htmlFor="name">Nazwa</Label>
                <Input
                    id="name"
                    name="name"
                    value={project.name ?? ""}
                    onChange={handleChange}
                    required
                    placeholder="[...]"
                />
            </div>
        </TabsContent>
    </Tabs>
</form>
\end{lstlisting}

Podobnie do wielu innych fragmentów kodu front-end aplikacji, wykorzystane zostały komponenty formularza biblioteki \textit{shadcn/ui}, dla usprawnienia realizacji części wyglądowej i dostępnościowej aplikacji. W tym przypadku komponenty \textit{Tabs}, \textit{TabsList}, \textit{TabsContent}, \textit{Label} i \textit{Input}.

\subsection{Zastosowanie middleware dla pewności zachowania poprawnej hierarchii}

W wielu ścieżkach obecnych w aplikacji, wykorzystywany jest dodatkowy komponent aplikacji, którym jest middleware (pośrednik przetwarzania żądań) posiadający za zadanie sprawdzać i upewnić się, że w sesji ustawiony jest zespół (z punktu interfejsu użytkownika oznacza to wybór zespołu jako aktywny) i projekt.

Warstwa ta jest kluczowa dla poprawnego działania aplikacji, ponieważ struktura wynikająca z założenia architektonicznego hierarchii zakłada, że nie może istnieć projekt bez zespołu. Wybór zastosowania warstwy middleware ponad wykorzystania warunków przy każdym żądaniu sprowadza się do ujednolicenia i ułatwienia logiki sprawdzającej.

\begin{lstlisting}[language=PHP,caption={Fragment middleware},label={lst:teams-addmember}]
$currentTeam = $user->currentTeam();
$currentProject = $user->currentProject();

$path = $request->path();

if (preg_match("/^projects\/\d+\/sprints/", $path)) {
    if (!$currentTeam) {
        return Inertia::render("error", [
            "message" => "[...]",
        ]);
    }

    if (!$currentProject) {
        return Inertia::render("error", [
            "message" => "[...]",
        ]);
    }
}

return $next($request);
\end{lstlisting}

Powyższy fragment demonstruje logikę procesu weryfikacji, czy na aktualnej sesji ustawiony jest zespół i projekt. Jeżeli ścieżka URL spełnia warunek porównujący adres ścieżki przez wyrażenie regularne (\textit{RegExp}), a nie jest określony aktualny zespół lub projekt, wyświetlana jest strona błędu. W tym przypadku zostało zastosowane wyrażenie regularne (\textit{RegExp}), które sprawdza, czy adres pasuje do wzorca: \texttt{projects/\{liczba\}/sprints}, ponieważ to te adresy wymagają wybranego zespołu i projektu.

\section{Integracja z API platformy GitHub}

Integracja z platformą GitHub została zaimplementowana w celu pobierania aktualnych informacji o repozytorium projektu, a także listy otwartych zgłoszeń (\textit{Issues}) oraz \textit{Pull Requestów}, aby umożliwić odnoszenie się do nich w zadaniach sprintów. Rozwiązanie to wykorzystuje publiczne endpointy REST API GitHub.

Po stronie serwerowej została udostępniona dedykowana ścieżka umożliwiająca pobranie danych z API GitHub dla wybranego projektu. Ścieżka ta weryfikuje poprawność konfiguracji ścieżki do repozytorium w modelu projektu oraz uprawnienia użytkownika, a następnie wykonuje zapytania HTTP do odpowiednich zasobów GitHub API.

\begin{lstlisting}[language=PHP,caption={Ścieżka API do pobierania zgłoszeń i pull requestów z GitHub},label={lst:github-route}]
Route::get("projects/{project}/github-issues-prs", [
    ProjectController::class,
    "fetchGithubIssuesAndPRs",
])->name("projects.github-issues-prs");
\end{lstlisting}

W ramach implementacji wykorzystywane są dwa podstawowe endpointy GitHub API:
\begin{itemize}
    \item GET \texttt{https://api.github.com/repos/\{owner\}/\{repo\}/issues} – pobranie listy zgłoszeń,
    \item GET \texttt{https://api.github.com/repos/\{owner\}/\{repo\}/pulls} – pobranie listy pull requestów.
\end{itemize}
Odpowiedzi API są filtrowane w celu wykluczenia pull requestów z listy zgłoszeń oraz mapowane do uproszczonej struktury danych wykorzystywanej przez warstwę klienta.

\begin{lstlisting}[language=PHP,caption={Fragment implementacji pobierania danych z GitHub API},label={lst:github-fetch}]
$issuesResponse = Http::get(
    "https://api.github.com/repos/{$repoPath}/issues",
    ["state" => "open", "per_page" => 100]
);

$prsResponse = Http::get(
    "https://api.github.com/repos/{$repoPath}/pulls",
    ["state" => "open", "per_page" => 100]
);
\end{lstlisting}

Po stronie interfejsu użytkownika zaimplementowano mechanizm ręcznej synchronizacji danych z GitHub. Użytkownik może zainicjować synchronizację za pomocą dedykowanego przycisku, co powoduje wysłanie żądania do serwera i aktualizację informacji. Dodatkowo, aktualny status synchronizacji oraz dane repozytorium prezentowane są w sekcji integracji projektu.

\begin{lstlisting}[language=JavaScript,caption={Wywołanie synchronizacji repozytorium GitHub z poziomu interfejsu},label={lst:github-sync}]
router.post(`/projects/${project.id}/sync-github`,
            {}, { preserveScroll: true });
\end{lstlisting}

Zastosowana integracja umożliwia powiązanie zadań sprintu z rzeczywistymi zgłoszeniami i pull requestami, co dodatkowo zwiększa przejrzystość procesu wytwórczego oraz pozwala na łatwe śledzenie postępów prac bez konieczności opuszczania aplikacji.

\clearpage

\section{Sprinty i tablica zadań}

Zgodnie z założeniami metodyki Scrum, jednym z kluczowych elementów aplikacji jest pełna obsługa Sprintów, stanowiących podstawową jednostkę planowania i realizacji pracy zespołu projektowego. W celu zapewnienia przejrzystego zarządzania zarówno Sprintami, jak i realizowanymi w ich ramach zadaniami, w aplikacji zastosowano widok tablicy zadań.

Zastosowanie tablicy umożliwia intuicyjne zarządzanie przepływem zadań pomiędzy stanami, a także pozwala na szybką ocenę postępu prac; do tego, wizualna forma prezentacji danych znacznie zwiększa czytelność interfejsu użytkownika.

\subsection{Logika biznesowa}

Logika biznesowa obsługi funkcjonalności sprintów jest podzielona na jasno określone moduły, które składają się z:

\begin{itemize}
    \item tworzenia sprintów, edycji detali sprintów i kategoryzacji na zaplanowane, aktualne i zakończone;
    \item dodawania i modyfikacji detali i kolejności zadań w sprintach, obsługi aktualizacji czasu rzeczywistego WebSocket;
    \item funkcjonalności komentowania zadań;
    \item funkcjonalności wiązania zadań z problemami i \textit{Pull-Requestami} pobranych z API platformy GitHub;
    \item przenoszenia zadań z i do backlogu.
\end{itemize}


Implementacja podstawowej funkcjonalności CRUD Sprintów przypomina tą, która obsługuje zespoły i projekty, przy oczywistej różnicy wykorzystania modelu relacyjnego \textit{Sprint}. Drugą największą różnicą jest sposób reprezentacji danych w interfejsie użytkownika, gdzie jest użyta tablica. Oznacza to, że zamiast liniowej listy (jaka została wykorzystana w przypadku wyświetlania listy projektów), są widoczne trzy kolumny organizujące Sprinty na \textit{Zaplanowane}, \textit{Aktywne} i \textit{Zakończone (Archiwum)}.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/sprints-tasks-projects-diagram.png}
    \caption{Diagram relacyjny tabel związanych z obsługą sprintów i zadań}
    \label{fig:placeholder}
\end{figure}

Do obsługi sprintów, zadań, zostały zaimplementowane tabele SQL widoczne na diagramie.

W ramach obsługi Sprintów i pochodnych funkcjonalności zostały zaimplementowane określone ścieżki:

\renewcommand{\arraystretch}{1.1}

\begin{longtable}{|
>{\raggedright\arraybackslash}p{2.2cm}|
>{\raggedright\arraybackslash}p{6.8cm}|
>{\raggedright\arraybackslash}p{5.5cm}|}
\caption{Ścieżki obsługi sprintów i zadań}
\label{tab:sprint-routes} \\
\hline
\textbf{Metoda HTTP} & \textbf{Ścieżka} & \textbf{Opis} \\
\hline
\endfirsthead

\hline
\textbf{Metoda HTTP} & \textbf{Ścieżka} & \textbf{Opis} \\
\hline
\endhead

GET &
\path{projects/{project}/sprints} &
Pobranie listy sprintów przypisanych do wybranego projektu. \\
\hline

GET &
\path{projects/{project}/sprints/create} &
Wyświetlenie formularza tworzenia nowego sprintu. \\
\hline

POST &
\path{projects/{project}/sprints} &
Utworzenie nowego sprintu w ramach projektu. \\
\hline

GET &
\path{projects/{project}/sprints/{sprint}} &
Wyświetlenie szczegółowych informacji o wybranym sprincie. \\
\hline

GET &
\path{projects/{project}/sprints/{sprint}/edit} &
Wyświetlenie formularza edycji sprintu. \\
\hline

PUT / PATCH &
\path{projects/{project}/sprints/{sprint}} &
Aktualizacja danych sprintu (np. nazwa, zakres czasowy, status). \\
\hline

DELETE &
\path{projects/{project}/sprints/{sprint}} &
Usunięcie sprintu z projektu. \\
\hline

GET &
\path{projects/{project}/sprints/{sprint}/tasks} &
Pobranie listy zadań przypisanych do sprintu. \\
\hline

POST &
\path{projects/{project}/sprints/{sprint}/tasks} &
Dodanie nowego zadania bezpośrednio do sprintu. \\
\hline

POST &
\path{projects/{project}/sprints/{sprint}/tasks/add-from-backlog} &
Dodanie zadania do sprintu z backlogu projektu. \\
\hline

POST &
\path{projects/{project}/sprints/{sprint}/tasks/reorder} &
Zmiana kolejności zadań w sprincie. \\
\hline

PUT &
\path{projects/{project}/sprints/{sprint}/tasks/{task}} &
Aktualizacja danych zadania przypisanego do sprintu. \\
\hline

POST &
\path{projects/{project}/sprints/{sprint}/tasks/{task}/move-to-backlog} &
Przeniesienie zadania ze sprintu do backlogu projektu. \\
\hline

\end{longtable}

\subsection{Interfejs tablicy zadań}

W ramach każdego sprintu użytkownik posiada dostęp do uporządkowanych wpisów, takich jak zadania, epiki i historyjki, które odzwierciedlają zakres realizowanych prac. Elementy te są zorganizowane w trzy podstawowe grupy: \textit{Zaplanowane}, \textit{Aktywne} i \textit{Zakończone}.

Aby ułatwić zarządzanie poszczególnymi stanami, a także uprościć wygląd interfejsu użytkownika, do wyświetlenia danych zastosowana jest tablica, w której kolumny odpowiadają stanom realizacji zadania, a w wierszach określone są poszczególne wpisy prezentowane jako karty. Takie podejście pozwala na łatwe przenoszenie elementów pomiędzy stanami oraz zapewnia czytelną wizualizację postępu prac w obrębie Sprintu.

Struktura tablicy opiera się na siatce trzech kolumn, w których zadania prezentowane są w postaci kart, co zapewnia spójność wizualną. Każda kolumna jednemu z możliwych stanów: \textit{Zaplanowane}, \textit{Aktywne} oraz \textit{Zakończone}.
Każda karta zawiera kluczowe informacje dotyczące zadania, takie jak tytuł, typ, priorytet, liczba punktów historyjek oraz dodatkowe metadane, np. przypisanie użytkownika czy referencje do systemu GitHub.

\begin{lstlisting}[language=JavaScript,caption={Definicja dostępnych kolumn tablicy zadań},label={lst:tasktable-columns}]
const COLUMNS = ["Planned", "Active", "Completed"] as const;

const STATUS_LABELS = {
    Planned: "Zaplanowane",
    Active: "Aktywne",
    Completed: "Zakonczone",
};
\end{lstlisting}

Każde zadanie renderowane jest jako osobny komponent karty, który odpowiada zarówno za prezentację danych, jak i obsługę interakcji użytkownika. Zastosowany mechanizm przeciągania i upuszczania kart umożliwia intuicyjne przenoszenie zadań pomiędzy kolumnami, co przekłada się na zmianę ich statusu. Logika ta została zaimplementowana w sposób niezależny od warstwy wizualnej, co ułatwia dalszy rozwój oraz testowanie komponentu.

\begin{lstlisting}[language=JavaScript,caption={Komponent karty zadania w tablicy},label={lst:tasktable-card}]
function TaskCard({ task }) {
    return (
        <Card>
            <CardHeader>
                <CardTitle>{task.title}</CardTitle>
            </CardHeader>
            <CardContent>
                <Badge>{task.priority}</Badge>
            </CardContent>
        </Card>
    );
}
\end{lstlisting}

\clearpage % for preventing cut from overflow

Dodatkowo użytkownik ma możliwość tworzenia nowych zadań bezpośrednio w wybranej kolumnie, jak również dodawania zadań z backlogu sprintu. Operacje te realizowane są z poziomu interfejsu tablicy, bez konieczności przechodzenia do innych widoków aplikacji. Dzięki temu tablica zadań pełni rolę centralnego narzędzia do bieżącego zarządzania zakresem prac sprintu oraz monitorowania postępu realizacji zadań.

\begin{lstlisting}[language=JavaScript,caption={Dodawanie nowego zadania do sprintu},label={lst:tasks-addtask}]
router.post(
    `/projects/${project.id}/sprints/${sprint.id}/tasks`,
    { title, status }
);
\end{lstlisting}

\subsection{Instalacja i konfiguracja mechanizmu WebSocket}

W celu zapewnienia komunikacji czasu rzeczywistego pomiędzy klientami aplikacji wykorzystano mechanizm WebSocket oparty o narzędzie Laravel Reverb. Reverb pełni rolę serwera pośredniczącego w transmisji zdarzeń emitowanych przez aplikację serwerową do podłączonych klientów. Instalacja rozwiązania została przeprowadzona przy użyciu dedykowanej komendy narzędziowej, która automatycznie konfiguruje niezbędne elementy środowiska.

Proces instalacji został zrealizowany poprzez wykonanie polecenia \texttt{reverb:install}, które generuje wymagane klucze identyfikacyjne aplikacji oraz dodaje odpowiednie wpisy konfiguracyjne do pliku środowiskowego \texttt{.env}. Następnie uruchomiono serwer WebSocket przy pomocy komendy \texttt{reverb:start}, która inicjuje proces nasłuchujący na określonym porcie.

\begin{lstlisting}[language=JavaScript,caption={Konfiguracja zmiennych środowiskowych Reverb},label={lst:reverb-env}]
REVERB_APP_ID=571916
REVERB_APP_KEY=ciutdjunr091jfx0n6wp
REVERB_APP_SECRET=rrya42mjysck9fyw6rdc
REVERB_HOST="localhost"
REVERB_PORT=8080
REVERB_SCHEME=http
\end{lstlisting}

Wygenerowane wartości identyfikatora aplikacji, klucza oraz sekretu są przypisywane automatycznie podczas procesu instalacji i wykorzystywane zarówno przez część serwerową, jak i kliencką aplikacji. Dzięki temu możliwe jest bezpieczne uwierzytelnienie połączeń oraz kontrola dostępu do kanałów prywatnych.

\subsection{Komunikacja czasu rzeczywistego przez WebSocket}

Komunikacja czasu rzeczywistego w systemie została zaimplementowana w oparciu o mechanizm broadcastowania zdarzeń aplikacyjnych. Po stronie serwera definiowane są zdarzenia odpowiadające kluczowym operacjom na zadaniach sprintu, takim jak ich tworzenie, aktualizacja, usuwanie oraz zmiana kolejności. Każde zdarzenie emitowane jest natychmiast po wykonaniu operacji.

Zdarzenia te publikowane są na prywatnych kanałach powiązanych z konkretnym sprintem, co umożliwia precyzyjne kierowanie komunikatów wyłącznie do użytkowników aktualnie pracujących w danym kontekście. Przekazywane dane zawierają jedynie niezbędne informacje umożliwiające aktualizację stanu interfejsu użytkownika.

\begin{lstlisting}[language=PHP,caption={Zdarzenie utworzenia zadania po stronie serwera},label={lst:task-created-event}]
class TaskCreated implements ShouldBroadcastNow
{
    public function __construct(
        public Sprint $sprint,
        public Task $task
    ) {}

    public function broadcastOn(): array
    {
        return [new PrivateChannel("sprint." . $this->sprint->id)];
    }

    public function broadcastAs(): string
    {
        return "task.created";
    }
}
\end{lstlisting}

Po stronie klienta zastosowano bibliotekę Laravel Echo, która umożliwia łatwe subskrybowanie kanałów oraz nasłuchiwanie na zdarzenia emitowane przez serwer. Konfiguracja klienta WebSocket obejmuje określenie hosta, portu, metody uwierzytelniania oraz sposobu przesyłania tokenu CSRF. Po zestawieniu połączenia aplikacja reaguje na otrzymane zdarzenia, aktualizując lokalny stan danych bez konieczności ręcznego odświeżania widoku.

\clearpage

\begin{lstlisting}[language=JavaScript,caption={Konfiguracja klienta WebSocket w aplikacji frontendowej},label={lst:echo-config}]
const echo = new Echo({
    broadcaster: "reverb",
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT ?? 8080,
    forceTLS: false,
    enabledTransports: ["ws"],
});
\end{lstlisting}

Zastosowane rozwiązanie pozwala na zachowanie spójności stanu tablicy zadań pomiędzy wieloma użytkownikami pracującymi równocześnie w ramach jednego sprintu. Mechanizm ten znacząco poprawia responsywność interfejsu oraz eliminuje konieczność cyklicznego odpytywania serwera o zmiany danych.

\subsection{Komentarze zadaniowe}

Każde zadanie posiada prostą, liniową sekcję komentarzy, w której każdy członek projektu może dodawać dowolną ilość komentarzy. System powstał w celu usprawnienia komunikacji w zespole, zapewniając miejsce na rozmowy i dzielenie się opiniami na temat danego zadania, a także oferując miejsce na dodawanie notatek odnośnie danego zadania.

Po stronie serwera zaimplementowano zestaw podstawowych operacji umożliwiających pobieranie, dodawanie, edycję oraz usuwanie komentarzy. Każdy komentarz jest powiązany z określonym zadaniem oraz użytkownikiem, który go utworzył. Dostęp do komentarzy jest ograniczony do użytkowników posiadających uprawnienia do danego projektu, a edycja i usuwanie komentarzy możliwe są wyłącznie w przypadku własnych wpisów.

\begin{lstlisting}[language=PHP,caption={Pobieranie listy komentarzy przypisanych do zadania},label={lst:task-comments-index}]
public function index(Project $project, Task $task)
{
    $comments = $task->comments()
        ->with("user")
        ->orderBy("created_at", "asc")
        ->get();

    return response()->json($comments);
}
\end{lstlisting}

Dodawanie nowego komentarza odbywa się poprzez wysłanie żądania HTTP zawierającego treść komentarza. Dane wejściowe są walidowane, a następnie zapisywane w bazie danych wraz z identyfikatorem aktualnie zalogowanego użytkownika. Po zapisaniu komentarz jest zwracany do klienta, co powoduje odświeżenie widoku.

\begin{lstlisting}[language=PHP,caption={Dodawanie komentarza po stronie serwera},label={lst:task-comments-store}]
TaskComment::create([
    "task_id" => $task->id,
    "user_id" => Auth::id(),
    "content" => $validated["content"],
]);
\end{lstlisting}

Po stronie klienta sekcja komentarzy została zaimplementowana jako osobny komponent frontendu. Odpowiada on za wyświetlanie listy komentarzy, obsługę formularza dodawania nowych wpisów oraz umożliwia edycję i usuwanie komentarzy przez ich autorów.

\begin{lstlisting}[language=JavaScript,caption={Wysyłanie nowego komentarza z poziomu frontendu},label={lst:task-comments-frontend}]
fetch(`/projects/${projectId}/tasks/${taskId}/comments`, {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        "X-CSRF-TOKEN": csrfToken,
    },
    body: JSON.stringify({ content: newComment }),
});
\end{lstlisting}

\section{Backlog projektowy}

W Scrum podstawową ideą jest aby zadania, zanim trafią do poszczególnych sprintów, znalazły się w liście wszystkich zadań do zrobienia, tj. do \textit{listy zaległości zadań}, najczęściej zwanego backlogiem.
Backlog - podobnie jak Sprinty - składają się z zadań, epików i historyjek. Zaimplementowane została więc lista zadań w backlogu i operacje przenoszenia zadań z i do backlogu i sprintów. Kolejność zadań w backlogu, podobnie jak te już przypisane do sprintów, można swobodnie ustawiać przy pomocy przycisków przenoszenia.

\subsection{Implementacja zadań backlogu}

Podobnie jak powyższe zasoby, implementacja składa się z zestawu ścieżek i kontrolera odpowiedzialnego za podstawowe operacje CRUD na zadaniach jeszcze nie przypisanych do żadnego sprintu. Zadania pobierane są wyłącznie dla danego projektu oraz filtrowane według braku przypisanego sprintu, a następnie sortowane zgodnie z ich zapisaną kolejnością. 
\clearpage
\begin{lstlisting}[language=PHP,caption={Pobieranie zadań z backlogu projektu},label={lst:backlog-index}]
$tasks = $project->tasks()
    ->whereNull("sprint_id")
    ->orderBy("position")
    ->get();
\end{lstlisting}

Dodawanie nowych zadań do backlogu odbywa się poprzez formularz po stronie klienta. Dane wejściowe są walidowane, a następnie zapisywane w bazie danych z odpowiednim statusem oraz pozycją w kolejności backlogu.

\begin{lstlisting}[language=PHP,caption={Dodawanie zadania do backlogu},label={lst:backlog-store}]
Task::create([
    "project_id" => $project->id,
    "title" => $validated["title"],
    "status" => "Backlog",
    "sprint_id" => null,
]);
\end{lstlisting}

Każde zadanie znajdujące się w backlogu może być edytowane lub usunięte przez użytkowników posiadających odpowiednie uprawnienia w projekcie.

\subsection{Zmiana kolejności zadań w backlogu}

Istotnym elementem backlogu jest możliwość ustalania priorytetów poprzez zmianę kolejności zadań. Każde zadanie posiada pole \texttt{position}, które określa jego miejsce na liście backlogu. Na serwerze zaimplementowano operacje przesuwania zadania w górę lub w dół listy, polegające na zamianie wartości tego pola pomiędzy sąsiadującymi zadaniami. Dzięki temu zachowana zostaje spójność kolejności bez konieczności przeliczania całego backlogu.

\subsection{Wyświetlanie listy zadań}

Lista zadań renderowana jest jako uporządkowana kolekcja kart, sortowanych według pola \texttt{position}. Każda karta prezentuje podstawowe informacje o zadaniu oraz zestaw akcji dostępnych dla użytkownika.

\begin{lstlisting}[language=JavaScript,caption={Renderowanie listy zadań w backlogu},label={lst:backlog-render}]
{tasks
    .sort((a, b) => a.position - b.position)
    .map(task => renderTask(task))}
\end{lstlisting}

\subsection{Filtrowanie i wyszukiwanie}

W celu usprawnienia pracy z backlogiem zaimplementowano również prosty system filtrowania zadań według typu, priorytetu oraz wyszukiwania. Operacje te wykonywane są po stronie klienta, bez dodatkowych zapytań do serwera.

\begin{lstlisting}[language=JavaScript,caption={Filtrowanie zadań po stronie klienta},label={lst:backlog-filter}]
const filteredTasks = tasks.filter(task =>
    task.title.toLowerCase().includes(searchQuery.toLowerCase()) &&
    (filterType === "all" || task.type === filterType)
);
\end{lstlisting}

\subsection{Tworzenie i edycja zadań}

Dodawanie oraz edycja zadań realizowane są za pomocą formularzy w okienkach modalnych - po zatwierdzeniu formularza dane wysyłane są do serwera.

\begin{lstlisting}[language=JavaScript,caption={Wysyłanie formularza tworzenia zadania},label={lst:backlog-create}]
router.post(`/projects/${project.id}/backlog`, {
    title,
    description,
    priority,
});
\end{lstlisting}

Analogicznie realizowana jest aktualizacja istniejącego zadania, z użyciem metody \texttt{PUT}.

\begin{lstlisting}[language=JavaScript,caption={Aktualizacja zadania w backlogu},label={lst:backlog-update}]
router.put(
    `/projects/${project.id}/backlog/${task.id}`,
    updatedData
);
\end{lstlisting}

\subsection{Dzielenie historyjek w zadania}

System wspiera dekompozycję złożonych elementów backlogu - takich jak epiki i historyjki użytkownika - na bardziej szczegółowe zadania techniczne. Użytkownik może dodać jednocześnie wiele podzadań do wybranego elementu, przypisując im osobne parametry takie jak opis, typ, priorytet, estymacja punktowa czy odpowiedzialna osoba. Obsługa logiki dekompozycji realizowana jest na poziomie kontrolera backlogu i umożliwia zachowanie hierarchii zadań w strukturze danych projektu.

\begin{lstlisting}[language=PHP, caption={Kontroler obsługujący tworzenie podzadań}, label={lst:create-subtasks-short}]
public function createSubtasks(Request $request,
                                Project $project, Task $task)
{
    $this->authorize("manageBacklog", $project);
    $validated = $request->validate([
        "subtasks" => "required|array|min:1",
        "subtasks.*.title" => "required|string|max:255"
    ]);

    foreach ($validated["subtasks"] as $data) {
        Task::create([
            "project_id" => $project->id,
            "parent_task_id" => $task->id,
            "title" => $data["title"],
            "status" => "Backlog",
        ]);
    }

    return redirect()->route("projects.backlog.index", $project->id);
}
\end{lstlisting}



\clearpage

\section{Inne funkcjonalności}

\subsection{Udostępnianie dokumentów}

Funkcjonalność udostępniania dokumentów stanowi wspólną przestrzeń do przechowywania informacji projektowych, takiej jak notatki zespołowe, ustalenia architektoniczne czy dokumentacja techniczna.
Dokumenty są przypisywane bezpośrednio do konkretnego projektu i prezentowane w uporządkowanej liście, co ułatwia ich przeglądanie oraz szybki dostęp do najważniejszych informacji. Tworzenie, edycja oraz usuwanie dokumentów są dostępne wyłącznie dla członków danego projektu, zgodnie z przypisanymi im uprawnieniami.

Podstawowe operacje na dokumentach zostały udostępnione za pomocą dedykowanych ścieżek, które obsługują wyświetlanie listy dokumentów oraz ich tworzenie w obrębie projektu.

\begin{lstlisting}[language=PHP,caption={Definicja tras obsługujących dokumenty projektowe},label={lst:documents-routes}]
Route::get("projects/{project}/documents",
            [DocumentController::class, "index"])
    ->name("projects.documents.index");

Route::post("projects/{project}/documents",
            [DocumentController::class, "store"])
    ->name("projects.documents.store");
\end{lstlisting}

Po stronie serwera kontroler odpowiada za walidację danych wejściowych oraz zapis dokumentów w bazie danych. Podczas tworzenia nowego dokumentu automatycznie wyznaczana jest jego pozycja na liście, co pozwala zachować spójny i przewidywalny układ dokumentów w interfejsie użytkownika.

\begin{lstlisting}[language=PHP,caption={Tworzenie nowego dokumentu w projekcie},label={lst:documents-store}]
Document::create([
    "project_id" => $project->id,
    "created_by" => Auth::id(),
    "title" => $validated["title"],
    "content" => $validated["content"] ?? "",
    "position" => $maxPosition + 1,
]);
\end{lstlisting}

\clearpage

\subsection{Zapis historii aktywności}

Historia aktywności projektu pozwala na śledzenie zdarzeń zachodzących w jego obrębie, takich jak tworzenie i edycja sprintów, zadań czy zmian w backlogu. Dzięki temu użytkownicy mają wgląd w to, kto i kiedy wykonał daną operację, co zwiększa przejrzystość pracy zespołowej oraz ułatwia analizę przebiegu realizacji projektu. Rejestrowane wpisy są powiązane zarówno z użytkownikiem, jak i z konkretnym obiektem (np. zadaniem lub sprintem), którego dana akcja dotyczyła.

Centralnym elementem tej funkcjonalności jest wykorzystanie mechanizmu cech \textit{trait}. W PHP trait stanowi sposób na współdzielenie logiki pomiędzy wieloma klasami bez konieczności stosowania dziedziczenia. W tym przypadku trait odpowiada za zapisywanie aktywności i może być łatwo dołączony do różnych kontrolerów lub serwisów, co pozwala na jednolite i spójne rejestrowanie zdarzeń w całej aplikacji.

\begin{lstlisting}[language=PHP,caption={Trait odpowiedzialny za rejestrowanie aktywności projektu},label={lst:logs-activity-trait}]
trait LogsActivity
{
    protected function logActivity(
        Project $project,
        string $action,
        Model $subject,
        array $metadata = [],
    ): ProjectActivity {
        return ProjectActivity::create([
            "project_id" => $project->id,
            "user_id" => Auth::id(),
            "action" => $action,
            "subject_type" => get_class($subject),
            "subject_id" => $subject->id,
            "metadata" => $metadata,
        ]);
    }
}
\end{lstlisting}

Zastosowanie traitu sprawia, że logowanie aktywności nie jest powielane w wielu miejscach kodu - każda operacja może w prosty sposób wywołać odpowiednią metodę zapisu zdarzenia.

Przegląd historii aktywności dostępny jest z poziomu projektu poprzez ścieżkę, która przekierowuje użytkownika do widoku listy zdarzeń.

\clearpage

\begin{lstlisting}[language=PHP,caption={Trasy obsługujące historię aktywności projektu},label={lst:activities-routes}]
Route::get("projects/{project}/activities",
            [ProjectController::class, "activities"])
    ->name("projects.activities.index");
\end{lstlisting}

Aktywności pobierane są w formie stronicowanej listy, z możliwością filtrowania według rodzaju akcji, użytkownika oraz zakresu dat, co pozwala użytkownikowi na szybkie znalezienie interesujących go zdarzeń.

\subsection{Retrospektywy}

Retrospektywy stanowią podsumowanie zakończonego sprintu i dają zespołowi przestrzeń do omówienia przebiegu prac oraz wyciągnięcia wniosków na przyszłość. Każda retrospektywa jest przypisana do konkretnego sprintu i może zostać utworzona wyłącznie po jego zakończeniu, co wymusza spójność z przyjętym procesem Scrum. Zawiera ona trzy podstawowe sekcje: elementy, które przebiegły pomyślnie, obszary problemowe oraz propozycje usprawnień na kolejne iteracje.

\begin{lstlisting}[language=PHP,caption={Trasy obsługujące retrospektywy sprintu},label={lst:retrospective-routes}]
Route::get("projects/{project}/sprints/{sprint}/retrospective",
            [RetrospectiveController::class, "show"]);
Route::post("projects/{project}/sprints/{sprint}/retrospective", 
            [RetrospectiveController::class, "store"]);
\end{lstlisting}

Retrospektywa jest powiązana ze sprintem oraz użytkownikiem, który ją utworzył. Podczas zapisu weryfikowany jest stan sprintu, co zapobiega dodawaniu retrospektyw do sprintów aktywnych lub planowanych.

Elementem retrospektyw jest możliwość głosowania na poszczególne punkty, co pozwala zespołowi wskazać najważniejsze obserwacje i problemy. Mechanizm ten wspiera priorytetyzację tematów do omówienia i ułatwia wyciąganie wniosków istotnych dla dalszego rozwoju projektu.

\begin{lstlisting}[language=PHP,caption={Rejestrowanie głosu użytkownika w retrospektywie},label={lst:retrospective-vote}]
RetrospectiveVote::updateOrCreate([
    "retrospective_id" => $retrospective->id,
    "user_id" => Auth::id(),
    "vote_type" => $validated["vote_type"],
], ["upvote" => $validated["upvote"]]);
\end{lstlisting}

\clearpage

\section{Testy jednostkowe}

Istotnym elementem zapewniającym jakość oraz stabilność aplikacji są testy jednostkowe, które pozwalają na automatyzację testowania aplikacji. W projekcie zostały one wykorzystane do weryfikacji poprawności działania kluczowych elementów logiki biznesowej, takich jak modele, kontrolery oraz polityki autoryzacji. Dzięki testom możliwe było szybkie wykrywanie błędów, bezpieczne wprowadzanie zmian oraz utrzymanie spójności zachowania aplikacji w miarę jej rozwoju. Do implementacji testów wykorzystano framework \textit{Pest}, który jest nowoczesnym narzędziem testowym dla PHP, bardzo dobrze zintegrowanym z ekosystemem frameworka Laravel.

\subsection{Instalacja i konfiguracja Pest}

Instalacja Pest w projekcie Laravel odbywa się przy pomocy menedżera pakietów Composer:

\begin{lstlisting}[language=bash,caption={Instalacja frameworka Pest}]
composer require pestphp/pest --dev
php artisan pest:install
\end{lstlisting}

Po wykonaniu powyższych komend w projekcie tworzona jest podstawowa struktura testów oraz pliki konfiguracyjne. Domyślnie testy umieszczane są w katalogu \texttt{tests/}, który dzieli się m.in. na:
\begin{itemize}
\item \texttt{Unit/} – testy jednostkowe,
\item \texttt{Feature/} – testy funkcjonalne (integracyjne).
\end{itemize}

Pest automatycznie integruje się z mechanizmami Laravel, takimi jak migracje testowej bazy danych, fabryki modeli czy obsługa sesji, co skutkuje brakiem potrzeby dodatkowej konfiguracji środowiska.

\subsection{Struktura przykładowego testu jednostkowego}

Jedną z największych zalet Pest od jego poprzednika, \textit{PHPUnit}, jest bardzo czytelna struktura testów. Każdy test zapisywany jest w postaci funkcji \texttt{test()}, której pierwszy argument opisuje testowany scenariusz w formie zdania, a drugi zawiera właściwą logikę testu.

Przykładem testu jednostkowego modelu \texttt{Project} jest sprawdzenie domyślnej wartości pola \texttt{status}:

\begin{lstlisting}[language=php,caption={Przykład testu jednostkowego modelu}]
test("project default status is active when not provided", function () {
    $team = Team::factory()->create();
    
    $project = Project::factory()->create([
        "team_id" => $team->id,
        "name" => "Testowy Projekt",
    ]);
    
    expect($project->status)->toBe("active");
});
\end{lstlisting}

\noindent Test ten:
\begin{itemize}
\item tworzy wymagane dane przy pomocy fabryk,
\item wykonuje akcję (utworzenie projektu),
\item sprawdza rezultat przy pomocy asercji \texttt{expect()}.
\end{itemize}

\noindent W projekcie wykorzystano trzy główne typy testów jednostkowych:

\begin{itemize}
\item \textbf{Testy modeli} - sprawdzające relacje, domyślne wartości, metody pomocnicze (np. \texttt{activeSprint()}),
\item \textbf{Testy polityk (Policies)} - weryfikujące poprawność uprawnień dla różnych ról zespołowych,
\item \textbf{Testy logiki aplikacyjnej} - obejmujące zachowanie powiązanych modeli (np. projekt–sprint).
\end{itemize}

Przykładem testu polityki autoryzacji jest sprawdzenie, czy użytkownik z rolą administratora może usuwać projekt:

\begin{lstlisting}[language=php,caption={Test polityki autoryzacji}]
test("delete returns true when user has admin role", function () {
    $user = User::factory()->create();
    $team = Team::factory()->create();
    $project = Project::factory()->create(["team_id" => $team->id]);
    $user->teams()->attach($team->id, ["role" => "admin"]);
    $policy = new ProjectPolicy();
    expect($policy->delete($user, $project))->toBeTrue();
});
\end{lstlisting}

\subsection{Uruchamianie testów}

\noindent Testy jednostkowe uruchamiane są z poziomu linii poleceń CLI przy pomocy polecenia:

\begin{lstlisting}[language=bash,caption={Uruchamianie wszystkich testów}]
php artisan test
\end{lstlisting}

\noindent lub, szczególnie w przypadku indywidualnych testów lub dla uruchomienia tylko danego podzbioru testów, bezpośrednio przez Pest:

\begin{lstlisting}[language=bash,caption={Uruchamianie testów przy pomocy Pest}]
./vendor/bin/pest
\end{lstlisting}

\noindent Na przykład:

\begin{lstlisting}[language=bash,caption={Uruchamianie tylko testów jednostkowych}]
./vendor/bin/pest tests/Unit
\end{lstlisting}

% ********** Koniec rozdziału **********

